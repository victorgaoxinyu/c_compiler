## Laxical Analysis
- strings -> tokens
- tokens
	- types
	- value
- Lexer

```
int main()
{
	int x = 50;
}

# tokens
<keyword, "int">
<identifier, "main">
<operator, "(">
...
```

Token types in our Compiler
- TOKEN_TYPE_IDENTIFIER
- TOKEN_TYPE_KEYWORD
- TOKEN_TYPE_OPERATOR
- TOKEN_TYPE_SYMBOL
- TOKEN_TYPE_NUMBER
- TOKEN_TYPE_STRING
- TOKEN_TYPE_COMMENT
- TOKEN_TYPE_NEWLINE

'(' and '[' are operators while ')' and ']' are symbol.

### Creating a number token
- Need to revisit this section once fixed gdb bug

#### Some gdb commands

```c
print *(struct token*)vector_at(lex_process->token_vec, )
// vector count
print vector_count(process->token_vec)
// set the peek pointer to the start
print vector_set_peek_pointer(process->token_vec, )
```



# Parsing

take token -> abstract syntax tree 

easier to iterate through a tree

```
int main()
{
	int x = 50;
}

// tree
function_node: main
|--body_node: body
|  |--variable_node: x
|      |--number_node: 50
|--vector_arguments
```

Why are parsers important

- provide structure for an input file
- nodes can branch off from each other providing stability in logic
- makes it easier to validate the code
- easier to compile the input file

#### Some gdb commands

```shell
print **(struct node**)(vector_back(process->node_vec))\
print *node_peek()
print *node_peek()->exp.left

step // step into the function
```



**need revise p28**

# Scope

Scope example

```c
int d;                    // Global Scope - Variable d
int main(int z)           // Function arguments scope - Variable Z
{
	int a;                // Function body scope - Variable A, B
	int b
}
```



Structure scopes

- struct bodies will have their own scopes that will have no parents
- resolver will deal with it

# Symbols

- functions we have identified during the compile process
- structures we have identified during the compile process
- global variables



Rules

- should never share the same name



### Some GDB commands

```c
print vector_count(node->var.type->array->brackets->n_brackets)

```



## Calculating Array Sizes

```c
int x[50]; // sizeof(int) * 50 -> 4 * 50
int y[30][20]; // sizeof(int) * 30 * 20 -> 4 * 30 * 20
char e[40][10][20]; // sizeof(char) * 40 * 10 * 20 -> 1 * 40 * 10 * 20 
```









